#!/bin/bash
export RBENV_VERSION=system
exec ruby "$0" "$@"
#!ruby
#/ Usage: ci-status [--skip-green|--failed] [--urls] [--ids] [branch|PR-url]
#/ Shows pretty ci status for the current repo and current branch (or the named branch).

require "date"
require "json"
require "net/http"
require "timeout"

def main(branch:, nwo:, token:, filter: :all, force_urls: false, show_ids: false)
  puts "Status for #{branch}:"
  to_show = []
  queries = [{}]
  while q = queries.shift
    raw_ci_status = run!({"GITHUB_TOKEN" => token}, "ci-status-raw", nwo, branch, q)
    ci_status = JSON.parse(raw_ci_status)
    if errors = ci_status["errors"]
      p errors
      exit 1
    end
    data = ci_status["data"]
    raise "expected 'data' in #{ci_status.inspect}" unless data.is_a?(Hash)
    repo = data["repository"]
    commit = repo["object"]
    if commit.nil?
      puts "No CI results"
      return
    end
    to_show += prepare_statuses(commit["status"]) if commit["status"]
    to_show += prepare_checks(commit["checkSuites"]) if commit["checkSuites"]

    queries += check_suite_queries(commit, q)
    queries += check_run_queries(commit, q)
  end

  # De-duplicate.
  to_show = to_show.group_by { |s| s[:url] }.map { |_, v| v.first }

  all_ok = !to_show.empty? && to_show.all? { |status| status[:state] == :success }
  case filter
  when :skip_green
    to_show.reject! { |status| status[:state] == :success }
  when :failed
    to_show.select! { |status| status[:state] == :failure }
  end
  show_statuses(to_show, config: {force_urls: force_urls, show_ids: show_ids})
  exit 2 unless all_ok

rescue JSON::ParserError => e
  $stderr.puts "#{e.class.name}: #{e}", raw_ci_status
  exit 1
end

def check_suite_queries(commit, _)
  res = []
  page_info = commit.dig("checkSuites", "pageInfo")
  if page_info["hasNextPage"]
    res.push({"checkSuiteCursor" => page_info["endCursor"]})
  end
  res
end

def check_run_queries(commit, q)
  res = []
  (commit.dig("checkSuites", "nodes") || []).each do |cs|
    page_info = cs.dig("checkRuns", "pageInfo")
    if page_info["hasNextPage"]
      res.push(q.merge({"checkRunCursor" => page_info["endCursor"]}))
    end
  end
  res
end

def usage
  puts File.read(__FILE__).lines.grep(/^#\//).join.gsub(/^#\/ /, '')
  exit 1
end

STATUS_STATES = {
  "SUCCESS" => :success,
  "NEUTRAL" => :neutral,
  "FAILURE" => :failure,
  "ERROR" => :failure,
}.freeze

def prepare_statuses(statuses)
  statuses["contexts"].map { |context| {
    id: context["id"],
    name: context["context"],
    description: context["description"],
    elapsed: "",
    state: STATUS_STATES.fetch(context["state"], :pending),
    state_string: context["state"],
    url: context["targetUrl"],
  } }
end

def prepare_checks(checks)
  checks["nodes"].flat_map do |suite|
    #app_name = suite["app"] ? suite["app"]["name"] : "(an app)"
    #puts "#{app_name}:"

    suite["checkRuns"]["nodes"].map { |run|
      if run["status"] != "COMPLETED"
        state_string = run["status"]
        state = :pending
      else
        state_string = run["conclusion"]
        if run["conclusion"] == "SUCCESS"
          state = :success
        elsif run["conclusion"] == "NEUTRAL"
          state = :neutral
        else
          state = :failure
        end
      end

      {
        id: run["id"],
        name: check_name(suite: suite, run: run),
        description: check_description(run),
        elapsed: check_elapsed(run),
        state: state,
        state_string: state_string,
        url: "#{run["detailsUrl"]} - #{run["permalink"]}",
      }
    }
  end
end

def check_name(suite:, run:)
  run_name = run.fetch("name")
  if workflow_name = suite.dig("workflowRun", "workflow", "name")
    "#{workflow_name} / #{run_name}"
  else
    run_name
  end
end

def check_description(run)
  status = run["conclusion"] || run["status"]
  if summary = run["summary"]
    if summary.lines.count > 1
      summary = summary.lines.first.strip + " ..."
    end
    "#{status} (#{summary})"
  else
    status
  end
end

def check_elapsed(run)
  start = run["startedAt"]
  stop = run["completedAt"]
  if stop
    " in #{DateTime.parse(stop).to_time.to_i - DateTime.parse(start).to_time.to_i} seconds"
  elsif start
    " for #{Time.now.to_i - DateTime.parse(start).to_time.to_i} seconds"
  else
    ""
  end
end

STATUS_SORT_ORDER = {
  :failure => 1,
  :pending => 2,
  :neutral => 3,
  :success => 4,
}

def show_statuses(status_data, config:)
  status_data.sort_by { |status| [STATUS_SORT_ORDER.fetch(status[:state], 99), status[:name]] }.each do |status|
    show_status(config: config, **status)
  end
end

def show_status(id:, name:, description:, state:, state_string:, url:, elapsed:, config:)
  force_urls = config.fetch(:force_urls)
  show_ids = config.fetch(:show_ids)
  opts =
    case state
    when :success
      {color: 32, icon: "✔︎", hide_url: true}
    when :neutral
      {color: 30, icon: "⊘", hide_url: true}
      # ❀
      # ⁐
      # ⊘
      # ∓
    when :failure
      {color: 31, icon: "✖︎"}
    when :pending
      {color: 33, icon: "●", label: "#{state_string} - "}
    else
      raise "unrecognized state #{state.inspect}"
    end

  printf "\033[%dm%s\033[0m %s%s%s - %s%s\n",
    opts[:color], opts[:icon],
    show_ids ? "[#{id}] " : "",
    opts[:label], name, description,
    elapsed
  if force_urls || !opts[:hide_url]
    puts "  #{url}"
  end
end

CI_STATUS_GQL_QUERY = <<-GQL
query ($owner: String!, $repo: String!, $ref: String!, $checkRunCursor: String, $checkSuiteCursor: String) {
  repository(owner: $owner, name: $repo) {
    object(expression: $ref) {
      ... on Commit {
        status {
          contexts {
            id
            context
            state
            description
            targetUrl
            createdAt
          }
        }
        checkSuites(first: 100, after: $checkSuiteCursor) {
          pageInfo { hasNextPage endCursor }
          nodes {
            app { name }
            workflowRun { workflow { name } }
            checkRuns(first: 100, after: $checkRunCursor) {
              pageInfo { hasNextPage endCursor }
              nodes {
                id
                conclusion
                detailsUrl
                name
                permalink
                status
                summary
                title
                startedAt
                completedAt
              }
            }
          }
        }
      }
    }
  }
}
GQL

def run!(env, _, nwo, branch, cursors)
  token = env.fetch("GITHUB_TOKEN")
  owner, repo = nwo.split("/", 2)
  req_data = {
    "query" => CI_STATUS_GQL_QUERY,
    "variables" => {
      "owner" => owner,
      "repo" => repo,
      "ref" => branch,
    }.merge(cursors),
  }

  req = Net::HTTP::Post.new("https://api.github.com/graphql")
  req.basic_auth token, "x-oauth-basic"
  req["Accept"] = "application/vnd.github.antiope-preview+json"
  req.body = JSON.dump(req_data)

  Timeout.timeout(30.0) do
    Net::HTTP.start("api.github.com", 443, use_ssl: true) do |http|
      http.request(req).body
    end
  end
end

opts = {}

while ARGV.first.to_s =~ /^-/
  case ARGV.shift
  when "--skip-green"
    opts[:filter] = :skip_green
  when "--failed", "--fail"
    opts[:filter] = :failed
  when "--urls"
    opts[:force_urls] = true
  when "--ids"
    opts[:show_ids] = true
  else
    usage
  end
end

usage if ARGV.size > 1

opts[:branch] = ARGV.first || `git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/^* //'`.strip
case opts[:branch]
when %r{\Ahttps://github.com/([^/]+/[^/]+)\z}
  opts[:nwo] = $1
  opts[:branch] = "HEAD"
when %r{\Ahttps://github.com/([^/]+/[^/]+)/commit/([a-f0-9]+)\z}
  opts[:nwo] = $1
  opts[:branch] = $2
when %r{\Ahttps://github.com/([^/]+/[^/]+)/pull/[0-9]+/commits/([a-f0-9]+)\z}
  opts[:nwo] = $1
  opts[:branch] = $2
when %r{\Ahttps://github.com/([^/]+/[^/]+)/pull/([0-9]+)}
  opts[:nwo] = $1
  opts[:branch] = "refs/pull/#{$2}/head"
when %r{\Ahttps://github.com/([^/]+/[^/]+)/(pull|compare|tree)/(.*)}
  opts[:nwo] = $1
  opts[:branch] = $3.split(/\.\.\./).last
when %r{\Ahttps://janky.githubapp.com/r/([^/]+/[^/]+)/(.*)}
  opts[:nwo] = $1
  opts[:branch] = $2
when %r{\Ahttps://}
  raise "Could not figure out nwo from #{opts[:branch].inspect}"
end

if ! opts[:nwo]
  remote_url = `git config remote.origin.url`.strip
  opts[:nwo] =
    case remote_url
    when %r{\Agit@.*?:(.*?)(\.git)?\z}
      $1
    when %r{\Ahttps?://[^/]+/(.*?)(\.git)?\z}
      $1
    else
      raise "Could not figure out nwo from remote url #{remote_url.inspect}"
    end
end

opts[:token] ||= ENV["GITHUB_TOKEN"]
opts[:token] ||=
  begin
    token_file = File.read(File.join(ENV["HOME"], ".github-token"))
    if token_file =~ /(^| )GITHUB_TOKEN=(\w+)/
      $2
    end
  end

if RUBY_VERSION.split(".").first.to_i >2
  main(**opts)
else
  main opts
end

# vim: ft=ruby
