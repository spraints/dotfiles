#!/usr/bin/env ruby
#/ Usage: projects
#/ List my projects and in-progress or in-review cards

require "json"
require "net/http"
require "timeout"
require "yaml"

COLUMNS = [
  # Spokes API
  "MDEzOlByb2plY3RDb2x1bW4xMjQ0OTM4MA==", # In progress
  "MDEzOlByb2plY3RDb2x1bW4xMjQ0OTQwMg==", # In review
  # Mind Meld
  "PC_lQDNTr7OFieqrs4Av6FizgDdaHM", # In progress
  "PC_lQDNTr7OFieqrs4Av6FizgDdaHQ", # Review in progress
]

def main(token:)
  results = get_data(token: token, query: QUERY, variables: {"ids" => COLUMNS})
  #results = JSON.parse(File.read("example.json"))
  if errors = results["errors"]
    p errors
    exit 1
  end
  show_results(collect_columns(results.fetch("data")))
end

def collect_columns(data)
  data.fetch("nodes").group_by { |column| column.dig("project", "name") }
end

def show_results(projects)
  projects.sort_by(&:first).each do |name, columns|
    puts "** #{name} **"
    columns.each do |column|
      puts "- #{column.fetch("name")}"
      cards = column.fetch("cards")
      total_cards = cards.fetch("totalCount")
      cards = cards.fetch("nodes")
      cards.each do |card|
        case card.fetch("state")
        when "REDACTED"
          puts "  - (redacted)"
        when "CONTENT_ONLY"
          content = card.fetch("content")
          assignees = content.fetch("assignees").fetch("nodes").map { |a| a.fetch("login") }
          assignees_str = assignees.empty? ? "" : " (#{assignees.join(",")})"
          puts "  - #{content.fetch("title")} (#{content.fetch("state")})#{assignees_str}"
          puts "    #{content.fetch("url")}"
        when "NOTE_ONLY"
          puts "  - #{card.fetch("note").lines.first}"
          puts "    #{card.fetch("url")}"
        end
      end
      remaining = total_cards - cards.size
      if remaining > 0
        puts "  (and #{remaining} more)"
      end
    end
  end
end

QUERY = <<END_QUERY
query($ids: [ID!]!) {
  nodes(ids: $ids) { ... columnDetails }
}
fragment columnDetails on ProjectColumn {
  id
  name
  project { id name }
  cards(first: 10) {
    totalCount
    nodes {
      id
      note
      state # CONTENT_ONLY or NOTE_ONLY or REDACTED
      url   # url of project card
      content {
        ...issueDetails
        ...pullDetails
      }
    }
  }
}
fragment issueDetails on Issue {
  issue_id: id
  url
  title
  state
  assignees(first: 10) {
    nodes { login }
  }
}
fragment pullDetails on PullRequest {
  pull_id: id
  url
  title
  state
  assignees(first: 10) {
    nodes { login }
  }
}
END_QUERY

def build_request(column_ids)
  variables = {"ids" => column_ids}
  columns = projects.values.flatten
  projects = projects.keys
  variables = {}
  projects.each_with_index do |proj, i|
    variables["project_#{i}"] = proj
  end
  columns.each_with_index do |col, i|
    variables["column_#{i}"] = col
  end
  variable_decls = variables.keys.map { |name| "$#{name}: ID!" }.join(", ")
  query = "query (#{variable_decls}) {\n"
  variables.keys.each do |name|
    # todo: replace this with 'nodes(ids: [])'
    query << "  #{name}: node(id: $#{name}) { ...projectDetails ...columnDetails }\n"
  end
  query << "}\n" + FRAGMENT
  return query, variables
end

def get_data(token:, query:, variables:)
  request = {query: query, variables: variables}

  req = Net::HTTP::Post.new("https://api.github.com/graphql")
  req["Authorization"] = "token #{token}"
  req.body = JSON.dump(request)

  Timeout.timeout(30.0) do
    Net::HTTP.start("api.github.com", 443, use_ssl: true) do |http|
      body = http.request(req).body
      #File.write("example.json", body)
      JSON.parse(body)
    end
  end
end

opts = {}

unless opts[:token] = ENV["GITHUB_TOKEN"]
  token_file = File.read(File.join(ENV["HOME"], ".github-token"))
  if token_file =~ /(^| )GITHUB_TOKEN=(\w+)/
    opts[:token] = $2
  end
end

main(opts)
